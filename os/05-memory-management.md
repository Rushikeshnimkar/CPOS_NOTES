---
layout: default
title: Memory Management
---

# Memory Management

[← Back to Home](../index.md)

---

## Table of Contents
- [Introduction to Memory Management](#introduction-to-memory-management)
- [Memory Hierarchy](#memory-hierarchy)
- [Address Binding](#address-binding)
- [Contiguous Memory Allocation](#contiguous-memory-allocation)
- [Fixed Partitioning](#fixed-partitioning)
- [Variable Partitioning](#variable-partitioning)
- [Paging](#paging)
- [Segmentation](#segmentation)
- [Fragmentation](#fragmentation)
- [Numerical Problems](#numerical-problems)
- [Formula Sheet](#formula-sheet)

---

## Introduction to Memory Management

### What is Memory Management?

> **Memory Management** is the process of controlling and coordinating computer memory, assigning portions called blocks to various running programs to optimize overall system performance.

### Goals of Memory Management

| Goal | Description |
|------|-------------|
| **Allocation** | Allocate memory to processes |
| **Relocation** | Move processes in memory |
| **Protection** | Prevent unauthorized access |
| **Sharing** | Allow controlled sharing |
| **Efficiency** | Minimize fragmentation |

---

## Memory Hierarchy

```
          ┌─────────────┐
Speed     │  Registers  │  ← Fastest, smallest
  ↑       ├─────────────┤
  │       │    Cache    │
  │       ├─────────────┤
  │       │ Main Memory │  ← RAM
  │       │   (RAM)     │
  │       ├─────────────┤
  │       │ Secondary   │  ← Hard disk, SSD
  │       │  Storage    │
  ↓       ├─────────────┤
Capacity  │  Tertiary   │  ← Tape, optical
  ↓       │  Storage    │  ← Slowest, largest
          └─────────────┘
```

---

## Address Binding

### Types of Addresses

| Type | Description |
|------|-------------|
| **Symbolic Address** | Variable names in source code |
| **Relocatable Address** | Relative addresses in object code |
| **Absolute/Physical Address** | Actual memory location |

### Binding Time

| Time | Description | Flexibility |
|------|-------------|-------------|
| **Compile Time** | Address known at compile | Must recompile if location changes |
| **Load Time** | Address assigned at loading | Relocatable code generated |
| **Execution Time** | Address can change during run | Requires hardware support (MMU) |

### Logical vs Physical Address

```
┌─────────────────┐                    ┌─────────────────┐
│    Process      │                    │  Physical       │
│  (Logical       │      MMU           │   Memory        │
│   Address       │ ──────────────►    │  (Physical      │
│   Space)        │  Translation       │   Address)      │
└─────────────────┘                    └─────────────────┘
```

| Logical Address | Physical Address |
|-----------------|------------------|
| Generated by CPU | Actual memory location |
| Virtual address | Used by memory unit |
| User's view | System's view |

---

## Contiguous Memory Allocation

### Concept

Each process is allocated a single contiguous section of memory.

```
┌───────────────────────────────────────────┐
│              Operating System             │
├───────────────────────────────────────────┤
│            Process 1                      │
├───────────────────────────────────────────┤
│            Process 2                      │
├───────────────────────────────────────────┤
│              Hole (Free)                  │
├───────────────────────────────────────────┤
│            Process 3                      │
└───────────────────────────────────────────┘
```

### Memory Protection

**Base and Limit Registers:**

```
Process Access:
             Logical Address
                   │
                   ▼
        ┌─────────────────────┐
Limit ──►│ Limit < Address?   │──Yes──► Trap (Error)
        └──────────┬──────────┘
                   │ No
                   ▼
Base  ────────► Address + Base = Physical Address
```

---

## Fixed Partitioning

### Concept

Memory is divided into fixed-size partitions at system startup.

### Equal-Size Partitions

```
Memory Size: 64 KB, Partition Size: 16 KB
┌────────────────┐
│ Partition 1    │ 16 KB
├────────────────┤
│ Partition 2    │ 16 KB
├────────────────┤
│ Partition 3    │ 16 KB
├────────────────┤
│ Partition 4    │ 16 KB
└────────────────┘
```

### Unequal-Size Partitions

```
Memory Size: 64 KB
┌────────────────┐
│ Partition 1    │  8 KB
├────────────────┤
│ Partition 2    │ 16 KB
├────────────────┤
│ Partition 3    │ 16 KB
├────────────────┤
│ Partition 4    │ 24 KB
└────────────────┘
```

### Advantages and Disadvantages

| Advantages | Disadvantages |
|------------|---------------|
| Simple implementation | Internal fragmentation |
| Low overhead | Limits process size |
| Fast allocation | Limited multiprogramming |

---

## Variable Partitioning

### Concept

Partitions created dynamically based on process needs.

### Example

```
Initial: 64 KB Memory

Time 0:                  Time 1:               Time 2:
┌────────────────┐       ┌────────────────┐    ┌────────────────┐
│                │       │    P1 (15KB)   │    │    P1 (15KB)   │
│  Free (64KB)   │  ──►  ├────────────────┤──► ├────────────────┤
│                │       │    Free (49KB) │    │    P2 (20KB)   │
│                │       │                │    ├────────────────┤
└────────────────┘       └────────────────┘    │    Free (29KB) │
                                               └────────────────┘
```

### Memory Allocation Strategies

#### 1. First Fit
- Allocate first hole that is big enough
- Fast but may leave small holes at beginning

#### 2. Best Fit
- Allocate smallest hole that is big enough
- Leaves smallest leftover hole
- Must search entire list

#### 3. Worst Fit
- Allocate largest available hole
- Leaves largest leftover hole
- Must search entire list

#### 4. Next Fit
- Like First Fit, but starts from last allocation point
- More even distribution

### Example: Allocation Strategies

**Memory Holes:** 100 KB, 500 KB, 200 KB, 300 KB, 600 KB

**Process Request:** 212 KB

| Strategy | Hole Selected | Remaining |
|----------|---------------|-----------|
| First Fit | 500 KB | 288 KB |
| Best Fit | 300 KB | 88 KB |
| Worst Fit | 600 KB | 388 KB |

---

## Paging

### Concept

> **Paging** is a memory management scheme that eliminates external fragmentation by dividing physical memory into fixed-size frames and logical memory into same-size pages.

### Key Terms

| Term | Description |
|------|-------------|
| **Page** | Fixed-size block of logical memory |
| **Frame** | Fixed-size block of physical memory |
| **Page Table** | Maps pages to frames |
| **Page Size** | Size of each page (e.g., 4 KB) |

### Address Translation

```
Logical Address (CPU) ───────► Physical Address (Memory)
           │                              ▲
           ▼                              │
    ┌──────────────┐                      │
    │ Page Number  │ ──► Page Table ──────┘
    │   (p)        │     ┌────┬────────┐
    ├──────────────┤     │  p │ Frame  │
    │   Offset     │     ├────┼────────┤
    │   (d)        │     │  0 │   5    │
    └──────────────┘     │  1 │   2    │
           │             │  2 │   8    │
           │             └────┴────────┘
           │                   │
           └───────────────────┴──► Physical Address = Frame × Page_Size + Offset
```

### Important Formulas

```
┌──────────────────────────────────────────────────────────────────────────┐
│                           PAGING FORMULAS                                │
├──────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  Page Number (p) = Logical Address / Page Size                          │
│                  = Logical Address DIV Page Size                         │
│                                                                          │
│  Page Offset (d) = Logical Address % Page Size                          │
│                  = Logical Address MOD Page Size                         │
│                                                                          │
│  Physical Address = (Frame Number × Page Size) + Offset                  │
│                                                                          │
│  Number of Pages = Logical Address Space / Page Size                     │
│                  = 2^(bits for logical address) / Page Size              │
│                                                                          │
│  Number of Frames = Physical Memory Size / Frame Size                    │
│                                                                          │
│  Bits for Page Number = log₂(Number of Pages)                           │
│                                                                          │
│  Bits for Offset = log₂(Page Size)                                      │
│                                                                          │
│  Bits for Frame Number = log₂(Number of Frames)                         │
│                                                                          │
│  Page Table Size = Number of Pages × Size of each entry                 │
│                                                                          │
│  Number of Page Table Entries = 2^(Bits for Page Number)                │
│                                                                          │
└──────────────────────────────────────────────────────────────────────────┘
```

### Page Table Entry Structure

```
┌─────────────────────────────────────────────────────────────┐
│ Frame │ Present │ Modified │ Protection │ Reference │ Cache │
│ Number│   Bit   │   Bit    │    Bits    │    Bit    │Control│
└─────────────────────────────────────────────────────────────┘
```

| Field | Purpose |
|-------|---------|
| Frame Number | Physical frame location |
| Present/Valid Bit | Page in memory (1) or not (0) |
| Modified (Dirty) Bit | Page has been modified |
| Protection Bits | Read, Write, Execute permissions |
| Reference Bit | Page has been accessed |

---

## Segmentation

### Concept

> **Segmentation** divides logical memory into variable-sized segments based on logical divisions (code, data, stack).

### Segment Table

```
Logical Address:
┌────────────────┬────────────────┐
│ Segment Number │    Offset      │
│      (s)       │      (d)       │
└────────────────┴────────────────┘

Segment Table:
┌─────────┬───────┬───────┐
│ Segment │ Base  │ Limit │
├─────────┼───────┼───────┤
│    0    │ 1400  │  400  │
│    1    │ 6300  │ 1000  │
│    2    │ 4300  │  500  │
└─────────┴───────┴───────┘
```

### Address Translation

```
Physical Address = Base[s] + d  (if d < Limit[s])
                   ERROR        (if d >= Limit[s])
```

### Paging vs Segmentation

| Feature | Paging | Segmentation |
|---------|--------|--------------|
| Size | Fixed | Variable |
| Fragmentation | Internal | External |
| User View | Single space | Multiple segments |
| Implementation | Simple | Complex |
| Sharing | Page-based | Segment-based |

---

## Fragmentation

### Types of Fragmentation

#### Internal Fragmentation

> Memory allocated but not used within a partition.

```
Example: Page Size = 4 KB, Process needs 6 KB

┌─────────────────┐
│   Page 1 (4KB)  │  ← Full
├─────────────────┤
│   Page 2 (4KB)  │  ← Only 2 KB used
│   ┌──────────┐  │
│   │  2 KB    │  │  ← Internal fragmentation
│   │  WASTED  │  │
│   └──────────┘  │
└─────────────────┘

Internal Fragmentation = Page Size - (Process Size MOD Page Size)
                       = 4 KB - (6 KB MOD 4 KB)
                       = 4 KB - 2 KB = 2 KB
```

#### External Fragmentation

> Total free memory exists but is not contiguous.

```
┌────────────────┐
│   Process A    │
├────────────────┤
│   Hole (5KB)   │  ← Free
├────────────────┤
│   Process B    │
├────────────────┤
│   Hole (8KB)   │  ← Free
├────────────────┤
│   Process C    │
├────────────────┤
│   Hole (7KB)   │  ← Free
└────────────────┘

Total Free: 5 + 8 + 7 = 20 KB
But cannot allocate 15 KB contiguous block!
```

### Solutions

| Solution | Description |
|----------|-------------|
| **Compaction** | Move processes to create larger holes |
| **Paging** | Eliminates external fragmentation |
| **Segmentation** | May still have external fragmentation |

---

## Numerical Problems

### Pattern 1: Logical to Physical Address Translation

**Problem 1:**
Given:
- Page Size = 4 KB = 4096 bytes
- Logical Address = 8196
- Page Table: Page 0 → Frame 5, Page 1 → Frame 6, Page 2 → Frame 1, Page 3 → Frame 2

**Solution:**

```
Step 1: Calculate Page Number and Offset

Page Number = Logical Address / Page Size
            = 8196 / 4096
            = 2 (integer division)

Offset = Logical Address % Page Size
       = 8196 % 4096
       = 4 (8196 - 2×4096 = 8196 - 8192 = 4)

Step 2: Find Frame Number from Page Table
Page 2 → Frame 1

Step 3: Calculate Physical Address
Physical Address = Frame Number × Page Size + Offset
                 = 1 × 4096 + 4
                 = 4096 + 4
                 = 4100

Answer: Physical Address = 4100
```

---

### Pattern 2: Address Bits Calculation

**Problem 2:**
A system has:
- 32-bit logical address
- Page size = 8 KB
- Physical memory = 1 GB
- Each page table entry = 4 bytes

Find:
a) Number of bits for offset
b) Number of bits for page number
c) Number of pages
d) Number of frames
e) Page table size

**Solution:**

```
Given:
- Logical Address = 32 bits
- Page Size = 8 KB = 8 × 1024 = 8192 bytes = 2^13 bytes
- Physical Memory = 1 GB = 2^30 bytes

(a) Bits for Offset:
    Offset bits = log₂(Page Size)
                = log₂(8192)
                = log₂(2^13)
                = 13 bits

(b) Bits for Page Number:
    Page Number bits = Total Address bits - Offset bits
                     = 32 - 13
                     = 19 bits

(c) Number of Pages:
    Number of Pages = 2^(Page Number bits)
                    = 2^19
                    = 524,288 pages

(d) Number of Frames:
    Number of Frames = Physical Memory / Frame Size
                     = 2^30 / 2^13
                     = 2^17
                     = 131,072 frames

(e) Page Table Size:
    Page Table Size = Number of Pages × Entry Size
                    = 2^19 × 4 bytes
                    = 2,097,152 bytes
                    = 2 MB

Answers:
a) 13 bits
b) 19 bits
c) 524,288 pages
d) 131,072 frames
e) 2 MB
```

---

### Pattern 3: Internal Fragmentation

**Problem 3:**
A system uses paging with page size = 2 KB. The following processes are loaded:
- Process A: 3200 bytes
- Process B: 5000 bytes
- Process C: 2048 bytes

Calculate internal fragmentation for each process and total.

**Solution:**

```
Page Size = 2 KB = 2048 bytes

Process A (3200 bytes):
    Pages needed = ⌈3200 / 2048⌉ = ⌈1.56⌉ = 2 pages
    Memory allocated = 2 × 2048 = 4096 bytes
    Internal fragmentation = 4096 - 3200 = 896 bytes

Process B (5000 bytes):
    Pages needed = ⌈5000 / 2048⌉ = ⌈2.44⌉ = 3 pages
    Memory allocated = 3 × 2048 = 6144 bytes
    Internal fragmentation = 6144 - 5000 = 1144 bytes

Process C (2048 bytes):
    Pages needed = ⌈2048 / 2048⌉ = 1 page
    Memory allocated = 1 × 2048 = 2048 bytes
    Internal fragmentation = 2048 - 2048 = 0 bytes

Total Internal Fragmentation = 896 + 1144 + 0 = 2040 bytes
```

---

### Pattern 4: Effective Memory Access Time (EMAT)

**Problem 4:**
Given:
- Memory access time = 200 ns
- TLB hit ratio = 98%
- TLB access time = 20 ns

Calculate Effective Memory Access Time.

**Solution:**

```
Formula:
EMAT = TLB_Hit_Ratio × (TLB_Time + Memory_Time) +
       TLB_Miss_Ratio × (TLB_Time + 2 × Memory_Time)

Where:
- TLB_Hit_Ratio = 0.98
- TLB_Miss_Ratio = 1 - 0.98 = 0.02
- TLB_Time = 20 ns
- Memory_Time = 200 ns

TLB Hit case: TLB lookup + 1 Memory access
TLB Miss case: TLB lookup + Memory (page table) + Memory (data)

EMAT = 0.98 × (20 + 200) + 0.02 × (20 + 200 + 200)
     = 0.98 × 220 + 0.02 × 420
     = 215.6 + 8.4
     = 224 ns

Answer: EMAT = 224 ns
```

---

### Pattern 5: Two-Level Paging

**Problem 5:**
A system has:
- Virtual address = 32 bits
- Page size = 4 KB
- Page table entry = 4 bytes
- Two-level paging is used

Find the structure of virtual address.

**Solution:**

```
Given:
- Virtual Address = 32 bits
- Page Size = 4 KB = 2^12 bytes
- PTE Size = 4 bytes

Step 1: Calculate Offset bits
Offset = log₂(4 KB) = log₂(4096) = 12 bits

Step 2: Remaining bits for page table
Remaining = 32 - 12 = 20 bits

Step 3: Entries per page table page
Entries per page = Page Size / PTE Size
                 = 4096 / 4
                 = 1024 entries = 2^10 entries

Step 4: Bits for each level
Bits per level = log₂(1024) = 10 bits

Virtual Address Structure:
┌──────────────┬──────────────┬───────────────┐
│  Outer Page  │  Inner Page  │    Offset     │
│   10 bits    │   10 bits    │    12 bits    │
└──────────────┴──────────────┴───────────────┘
        └────── Page Number (20 bits) ───────┘
```

---

### Pattern 6: Memory Allocation Strategies

**Problem 6:**
Memory available: 100 KB, 500 KB, 200 KB, 300 KB, 600 KB

Processes arriving: P1(212 KB), P2(417 KB), P3(112 KB), P4(426 KB)

Show allocation using First Fit, Best Fit, and Worst Fit.

**Solution:**

```
Initial Holes: 100, 500, 200, 300, 600 (in order)

FIRST FIT (allocate first hole that fits):
┌─────────┬────────────┬─────────────────────────────────────┐
│ Process │ Size (KB)  │ Hole Allocated → Remaining          │
├─────────┼────────────┼─────────────────────────────────────┤
│   P1    │    212     │ 500 KB → 288 KB                     │
│   P2    │    417     │ 600 KB → 183 KB                     │
│   P3    │    112     │ 288 KB → 176 KB                     │
│   P4    │    426     │ Cannot allocate (no fit)            │
└─────────┴────────────┴─────────────────────────────────────┘
Result: Holes after = 100, 176, 200, 300, 183

BEST FIT (allocate smallest hole that fits):
┌─────────┬────────────┬─────────────────────────────────────┐
│ Process │ Size (KB)  │ Hole Allocated → Remaining          │
├─────────┼────────────┼─────────────────────────────────────┤
│   P1    │    212     │ 300 KB → 88 KB                      │
│   P2    │    417     │ 500 KB → 83 KB                      │
│   P3    │    112     │ 200 KB → 88 KB                      │
│   P4    │    426     │ 600 KB → 174 KB                     │
└─────────┴────────────┴─────────────────────────────────────┘
Result: Holes after = 100, 83, 88, 88, 174

WORST FIT (allocate largest hole):
┌─────────┬────────────┬─────────────────────────────────────┐
│ Process │ Size (KB)  │ Hole Allocated → Remaining          │
├─────────┼────────────┼─────────────────────────────────────┤
│   P1    │    212     │ 600 KB → 388 KB                     │
│   P2    │    417     │ 500 KB → 83 KB                      │
│   P3    │    112     │ 388 KB → 276 KB                     │
│   P4    │    426     │ Cannot allocate (largest=300)       │
└─────────┴────────────┴─────────────────────────────────────┘
Result: Holes after = 100, 83, 200, 300, 276
```

---

### Pattern 7: Segmentation Address Translation

**Problem 7:**
Given segment table:

| Segment | Base | Limit |
|---------|------|-------|
| 0 | 219 | 600 |
| 1 | 2300 | 14 |
| 2 | 90 | 100 |
| 3 | 1327 | 580 |
| 4 | 1952 | 96 |

Calculate physical address for:
a) (0, 430)
b) (1, 10)
c) (2, 500)
d) (3, 400)

**Solution:**

```
Format: (Segment Number, Offset)
Physical Address = Base + Offset (if Offset < Limit)
                   Error (if Offset >= Limit)

(a) Segment 0, Offset 430:
    Limit[0] = 600, Offset = 430
    430 < 600 ✓
    Physical Address = 219 + 430 = 649

(b) Segment 1, Offset 10:
    Limit[1] = 14, Offset = 10
    10 < 14 ✓
    Physical Address = 2300 + 10 = 2310

(c) Segment 2, Offset 500:
    Limit[2] = 100, Offset = 500
    500 >= 100 ✗
    SEGMENTATION FAULT (Address out of bounds)

(d) Segment 3, Offset 400:
    Limit[3] = 580, Offset = 400
    400 < 580 ✓
    Physical Address = 1327 + 400 = 1727

Answers:
a) 649
b) 2310
c) Segmentation Fault
d) 1727
```

---

### Pattern 8: Page Table Size

**Problem 8:**
Calculate page table size for:
- Virtual address space = 4 GB
- Page size = 4 KB
- Page table entry size = 4 bytes

**Solution:**

```
Given:
- Virtual Address Space = 4 GB = 2^32 bytes
- Page Size = 4 KB = 2^12 bytes
- PTE Size = 4 bytes

Step 1: Calculate number of pages
Number of Pages = Virtual Address Space / Page Size
                = 2^32 / 2^12
                = 2^20 pages

Step 2: Calculate page table size
Page Table Size = Number of Pages × PTE Size
                = 2^20 × 4 bytes
                = 4 × 2^20 bytes
                = 4 MB

Answer: Page Table Size = 4 MB
```

---

### Pattern 9: Memory Utilization

**Problem 9:**
A memory system has:
- Total memory = 16 MB
- OS uses = 4 MB
- Fixed partitions: 2 MB, 4 MB, 4 MB, 2 MB
- Processes loaded: 1.8 MB, 3.5 MB, 3.8 MB, 1.5 MB

Calculate:
a) Total internal fragmentation
b) Memory utilization percentage

**Solution:**

```
Available memory = 16 MB - 4 MB (OS) = 12 MB
Partitions: 2 MB, 4 MB, 4 MB, 2 MB

Allocation:
P1 (1.8 MB) → 2 MB partition, Internal frag = 2 - 1.8 = 0.2 MB
P2 (3.5 MB) → 4 MB partition, Internal frag = 4 - 3.5 = 0.5 MB
P3 (3.8 MB) → 4 MB partition, Internal frag = 4 - 3.8 = 0.2 MB
P4 (1.5 MB) → 2 MB partition, Internal frag = 2 - 1.5 = 0.5 MB

(a) Total Internal Fragmentation:
    = 0.2 + 0.5 + 0.2 + 0.5
    = 1.4 MB

(b) Memory Utilization:
    Total Process Size = 1.8 + 3.5 + 3.8 + 1.5 = 10.6 MB
    Total Partition Size = 2 + 4 + 4 + 2 = 12 MB
    
    Utilization = (Total Process Size / Total Partition Size) × 100
                = (10.6 / 12) × 100
                = 88.33%

Answers:
a) 1.4 MB
b) 88.33%
```

---

### Pattern 10: Multi-level Page Table

**Problem 10:**
A computer with 64-bit virtual address uses:
- Page size = 8 KB
- Page table entry = 8 bytes
- Three-level page table

Find the number of bits in each field.

**Solution:**

```
Given:
- Virtual Address = 64 bits
- Page Size = 8 KB = 2^13 bytes
- PTE Size = 8 bytes

Step 1: Offset bits
Offset = log₂(8 KB) = log₂(8192) = 13 bits

Step 2: Entries per page table page
Entries = Page Size / PTE Size
        = 8192 / 8
        = 1024 = 2^10 entries

Bits per index = log₂(1024) = 10 bits

Step 3: Total bits for page number
Page Number bits = 64 - 13 = 51 bits

Step 4: Three-level structure
If we use 3 levels with equal division:
Level 1: 10 bits (2^10 entries)
Level 2: 10 bits
Level 3: 10 bits
Total: 30 bits

Remaining: 51 - 30 = 21 bits unused (or extend levels)

Alternative: Unequal division
Level 1: 17 bits
Level 2: 17 bits  
Level 3: 17 bits
Total: 51 bits ✓

Virtual Address Structure:
┌──────────┬──────────┬──────────┬────────────┐
│ Level 1  │ Level 2  │ Level 3  │   Offset   │
│ 17 bits  │ 17 bits  │ 17 bits  │  13 bits   │
└──────────┴──────────┴──────────┴────────────┘
```

---

## Formula Sheet

### Quick Reference

```
┌────────────────────────────────────────────────────────────────────────────┐
│                          MEMORY MANAGEMENT FORMULAS                        │
├────────────────────────────────────────────────────────────────────────────┤
│                                                                            │
│ PAGING                                                                     │
│ ───────                                                                    │
│ Page Number = Logical Address DIV Page Size                                │
│ Offset = Logical Address MOD Page Size                                     │
│ Physical Address = Frame Number × Page Size + Offset                       │
│                                                                            │
│ Number of Pages = 2^(bits for page number)                                │
│ Number of Frames = Physical Memory / Frame Size                            │
│                                                                            │
│ Page Table Size = Number of Pages × Entry Size                            │
│                                                                            │
│ Bits for Offset = log₂(Page Size)                                         │
│ Bits for Page Number = Logical Address bits - Offset bits                 │
│ Bits for Frame Number = log₂(Number of Frames)                            │
│                                                                            │
├────────────────────────────────────────────────────────────────────────────┤
│                                                                            │
│ FRAGMENTATION                                                              │
│ ─────────────                                                              │
│ Internal Fragmentation = Allocated Size - Actual Size                     │
│ Average Internal Frag (per process) ≈ Page Size / 2                       │
│                                                                            │
├────────────────────────────────────────────────────────────────────────────┤
│                                                                            │
│ EFFECTIVE MEMORY ACCESS TIME (EMAT)                                        │
│ ────────────────────────────────────                                       │
│                                                                            │
│ With TLB:                                                                  │
│ EMAT = h(t + m) + (1-h)(t + 2m)                                           │
│      = t + m + (1-h)m                                                      │
│                                                                            │
│ Where: h = TLB hit ratio                                                   │
│        t = TLB access time                                                 │
│        m = Memory access time                                              │
│                                                                            │
├────────────────────────────────────────────────────────────────────────────┤
│                                                                            │
│ SEGMENTATION                                                               │
│ ────────────                                                               │
│ Physical Address = Base[segment] + Offset  (if Offset < Limit)            │
│                                                                            │
├────────────────────────────────────────────────────────────────────────────┤
│                                                                            │
│ MULTI-LEVEL PAGING                                                         │
│ ───────────────────                                                        │
│ Entries per page = Page Size / Entry Size                                  │
│ Bits per level = log₂(Entries per page)                                   │
│                                                                            │
├────────────────────────────────────────────────────────────────────────────┤
│                                                                            │
│ MEMORY UTILIZATION                                                         │
│ ──────────────────                                                         │
│ Utilization = (Used Memory / Total Memory) × 100%                          │
│                                                                            │
│ Degree of Multiprogramming = Number of processes in memory                 │
│                                                                            │
└────────────────────────────────────────────────────────────────────────────┘
```

---

## Practice Problems

### Problem Set 1: Address Translation

1. Page size = 2 KB, Logical address = 5000. Find page number and offset.
2. Page size = 4 KB, Frame 3 assigned to page 1, offset = 100. Find physical address.
3. 16-bit logical address, 4 KB page. How many pages possible?

### Problem Set 2: Page Table

1. 32-bit address, 8 KB page, 4-byte entry. Calculate page table size.
2. 48-bit address, 4 KB page, two-level paging. Design the address structure.

### Problem Set 3: EMAT

1. TLB hit ratio = 80%, TLB time = 10 ns, Memory time = 100 ns. Calculate EMAT.
2. For EMAT ≤ 150 ns with times above, what minimum hit ratio is needed?

### Problem Set 4: Fragmentation

1. Page size = 3 KB. Process sizes: 5 KB, 7 KB, 10 KB. Calculate total internal fragmentation.
2. Holes: 100, 200, 50, 80. Request: 75 KB. Show First Fit and Best Fit allocation.

---

## Summary

- Memory management handles allocation, protection, and sharing
- Fixed partitioning causes internal fragmentation
- Variable partitioning causes external fragmentation
- Paging eliminates external fragmentation
- Segmentation provides logical view of memory
- TLB improves address translation speed
- Multi-level paging handles large address spaces

---

[← Previous: Processes](04-processes.md) | [Next: Virtual Memory →](06-virtual-memory.md)
